//
//  WRCustomView.swift
//  Custom Views
//
//  Created by Wasim Raza on 28/02/19.
//  Copyright Â© 2019 Wasim Raza. All rights reserved.
//

import Foundation
import UIKit
import QuartzCore

//MARK:- UIView Custom Properties
@IBDesignable open class WRCustomView: UIView {
    @IBInspectable var roundTopLeftCorner: Bool = false
    @IBInspectable var roundTopRightCorner: Bool = false
    @IBInspectable var roundBottomLeftCorner: Bool = false
    @IBInspectable var roundBottomRightCorner: Bool = false
    @IBInspectable var roundTopCorner: Bool = false
    
    private var shadowLayer: CAShapeLayer!
    
    func roundCorners(cornerRadius: Double) {
        
        if #available(iOS 10.0, *) {
            if roundTopLeftCorner {
                self.layer.maskedCorners = [.layerMinXMinYCorner]
            }else if roundTopRightCorner {
                self.layer.maskedCorners = [.layerMaxXMinYCorner]
            }else if roundBottomLeftCorner {
                self.layer.maskedCorners = [.layerMinXMaxYCorner]
            }else if roundBottomRightCorner {
                self.layer.maskedCorners = [.layerMaxXMaxYCorner]
            }
            
            if roundTopLeftCorner && roundTopRightCorner {
                self.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]
            }
                  
            if roundBottomLeftCorner && roundBottomRightCorner {
                self.layer.maskedCorners = [.layerMinXMaxYCorner, .layerMaxXMaxYCorner]
            }
            
            if roundTopLeftCorner && roundTopRightCorner && roundBottomLeftCorner && roundBottomRightCorner  {
                self.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner, .layerMinXMaxYCorner, .layerMaxXMaxYCorner]
            }
            self.layer.cornerRadius = CGFloat(cornerRadius)
            self.clipsToBounds = true
            
            
        } else {
            var path = UIBezierPath()
            
            if roundTopLeftCorner {
                path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topLeft], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
            }
            if roundTopRightCorner {
                path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
            }
            if roundBottomLeftCorner {
                path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.bottomLeft], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
            }
            if roundBottomRightCorner {
                path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.bottomRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
            }
            if roundTopLeftCorner && roundTopRightCorner {
                path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topLeft, .topRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
            }
            if roundTopLeftCorner && roundTopRightCorner && roundBottomLeftCorner && roundBottomRightCorner  {
                path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topLeft, .topRight, .bottomLeft, .bottomRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
            }
            let maskLayer = CAShapeLayer()
            maskLayer.frame = self.bounds
            maskLayer.path = path.cgPath
            self.layer.mask = maskLayer
        }
    }

    
    open override func layoutSubviews() {
        super.layoutSubviews()
        if roundTopCorner{
            roundCorners(cornerRadius: cornerRadius )
        }
    }
    
    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
    @IBInspectable var cornerRadius: Double {
        get {
            return Double(self.layer.cornerRadius)
        }
        set {
            if !roundTopCorner{
                self.layer.cornerRadius = CGFloat(newValue)
            }else{
                roundCorners(cornerRadius: newValue)
            }
            
        }
    }
    
    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
    @IBInspectable var borderWidth: Double {
        get {
            return Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.
    @IBInspectable var borderColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.borderColor!)
        }
        set {
            self.layer.borderColor = newValue?.cgColor
        }
    }
    
    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
    @IBInspectable var shadowColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.shadowColor!)
        }
        set {
            self.layer.shadowColor = newValue?.cgColor
        }
    }
    
    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
    @IBInspectable var shadowOpacity: Float {
        get {
            return self.layer.shadowOpacity
        }
        set {
            self.layer.shadowOpacity = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowOffset: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowSize: CGFloat {
        
        get {
            return self.layer.shadowPath as! CGFloat
        }
        set {
            let shadowPath = UIBezierPath(rect: CGRect(x: self.frame.origin.x - newValue / 2,
                                                       y: self.frame.origin.x - newValue / 2,
                                                       width: self.frame.size.width + newValue,
                                                       height: self.frame.size.height + newValue))
            self.layer.shadowPath = shadowPath.cgPath
        }
    }
    
    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
    @IBInspectable var shadowRadius: Double {
        get {
            return Double(self.layer.shadowRadius)
        }
        set {
            self.layer.shadowRadius = CGFloat(newValue)
        }
    }
    
    /*// Only override draw() if you perform custom drawing.
    // An empty implementation adversely affects performance during animation.
    override func draw(_ rect: CGRect) {
        // Drawing code
    }*/

}


//MARK:- UITextField Custom Properties

@IBDesignable open class WRCustomTextField: UITextField {
    
    var topBorder: UIView?
    var bottomBorder: UIView?
    var leftBorder: UIView?
    var rightBorder: UIView?
    
    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
    @IBInspectable var cornerRadius: Double {
        get {
            return Double(self.layer.cornerRadius)
        }
        set {
            self.layer.cornerRadius = CGFloat(newValue)
        }
    }
    
    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
    @IBInspectable var borderWidth: Double {
        get {
            return Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.
    @IBInspectable var borderColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.borderColor!)
        }
        set {
            self.layer.borderColor = newValue?.cgColor
        }
    }
    
    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
    @IBInspectable var shadowColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.shadowColor!)
        }
        set {
            self.layer.shadowColor = newValue?.cgColor
        }
    }
    
    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
    @IBInspectable var shadowOpacity: Float {
        get {
            return self.layer.shadowOpacity
        }
        set {
            self.layer.shadowOpacity = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowOffset: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    
    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
    @IBInspectable var shadowRadius: Double {
        get {
            return Double(self.layer.shadowRadius)
        }
        set {
            self.layer.shadowRadius = CGFloat(newValue)
        }
    }
    
    
    /// The Padding Left and Rght . Defaults 0.
    @IBInspectable var paddingLeft: CGFloat = 0
    @IBInspectable var paddingRight: CGFloat = 0
    
    override open func textRect(forBounds bounds: CGRect) -> CGRect {
        return CGRect(x: bounds.origin.x + paddingLeft, y: bounds.origin.y, width: bounds.size.width - paddingLeft - paddingRight, height: bounds.size.height)
    }
    
    override open func editingRect(forBounds bounds: CGRect) -> CGRect {
        return textRect(forBounds: bounds)
    }
    
/* /// The Particular border . Defaults 0.
    @IBInspectable var bottomLineWidth : CGFloat = 0 {
        didSet{
            let border: CALayer = CALayer()
            border.borderColor = UIColor.darkGray.cgColor
            self.frame = CGRect(x: 0, y: self.frame.size.height - bottomLineWidth, width: self.frame.size.width, height: self.frame.size.height)
            //self.frame = CGRectMake(0, self.frame.size.height - bottomLineWidth, self.frame.size.width, self.frame.size.height)
            border.borderWidth = CGFloat(borderWidth)
            self.layer.addSublayer(border)
            self.layer.masksToBounds = true
        }
    }
    
    @IBInspectable var bottomLineColor : UIColor = UIColor.lightGray{
        didSet {
            let border: CALayer = CALayer()
            border.borderColor = bottomLineColor.cgColor
        }
    }
    
    @IBInspectable var leftImage : String = "" {
        didSet {
            leftViewMode = UITextField.ViewMode.always
            let imageView = UIImageView();
            imageView.frame = CGRect(x: self.frame.origin.x+5, y: self.frame.origin.y+5, width: 30, height: self.frame.size.height-4)
            
            let image = UIImage(named:leftImage);
            imageView.image = image;
            leftView = imageView;
            
        }
    }
    
    @IBInspectable var topBorderColor : UIColor = UIColor.clear
    @IBInspectable var topBorderHeight : CGFloat = 0 {
        didSet{
            if topBorder == nil{
                topBorder = UIView()
                topBorder?.backgroundColor=topBorderColor;
                topBorder?.frame = CGRect(x: 0, y: 0, width: self.frame.size.width, height: topBorderHeight)
                addSubview(topBorder!)
            }
        }
    }
    
    @IBInspectable var bottomBorderColor : UIColor = UIColor.clear
    @IBInspectable var bottomBorderHeight : CGFloat = 0 {
        didSet{
            if bottomBorder == nil{
                bottomBorder = UIView()
                bottomBorder?.backgroundColor=bottomBorderColor;
                bottomBorder?.frame = CGRect(x: 0, y: self.frame.size.height - bottomBorderHeight, width: self.frame.size.width, height: bottomBorderHeight)
                addSubview(bottomBorder!)
            }
        }
    }
    
    @IBInspectable var leftBorderColor : UIColor = UIColor.clear
    @IBInspectable var leftBorderHeight : CGFloat = 0 {
        didSet{
            if leftBorder == nil{
                leftBorder = UIView()
                leftBorder?.backgroundColor=leftBorderColor;
                leftBorder?.frame = CGRect(x: 0, y: 0, width: leftBorderHeight, height: self.frame.size.height)
                addSubview(leftBorder!)
            }
        }
    }
    
    @IBInspectable var rightBorderColor : UIColor = UIColor.clear
    @IBInspectable var rightBorderHeight : CGFloat = 0 {
        didSet{
            if rightBorder == nil{
                rightBorder = UIView()
                rightBorder?.backgroundColor=topBorderColor;
                rightBorder?.frame = CGRect(x: self.frame.size.width - rightBorderHeight, y: 0, width: rightBorderHeight, height: self.frame.size.height)
                addSubview(rightBorder!)
            }
        }
    }*/
    
    /*// Only override draw() if you perform custom drawing.
     // An empty implementation adversely affects performance during animation.
     override func draw(_ rect: CGRect) {
     // Drawing code
     }*/
}


//MARK:- UITextView Custom Properties

@IBDesignable open class WRCustomTextView: UITextView {
    
    var topBorder: UIView?
    var bottomBorder: UIView?
    var leftBorder: UIView?
    var rightBorder: UIView?
    
    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
    @IBInspectable var cornerRadius: Double {
        get {
            return Double(self.layer.cornerRadius)
        }
        set {
            self.layer.cornerRadius = CGFloat(newValue)
        }
    }
    
    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
    @IBInspectable var borderWidth: Double {
        get {
            return Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.
    @IBInspectable var borderColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.borderColor!)
        }
        set {
            self.layer.borderColor = newValue?.cgColor
        }
    }
    
    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
    @IBInspectable var shadowColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.shadowColor!)
        }
        set {
            self.layer.shadowColor = newValue?.cgColor
        }
    }
    
    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
    @IBInspectable var shadowOpacity: Float {
        get {
            return self.layer.shadowOpacity
        }
        set {
            self.layer.shadowOpacity = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowOffset: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    
    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
    @IBInspectable var shadowRadius: Double {
        get {
            return Double(self.layer.shadowRadius)
        }
        set {
            self.layer.shadowRadius = CGFloat(newValue)
        }
    }
    
    /// The placeHolderColor . Defaults Black.
    @IBInspectable var placeHolderColor : UIColor = UIColor.lightGray{
        didSet {
            setValue(placeHolderColor, forKeyPath: "_placeholderLabel.textColor")
        }
    }
    
    /// The Padding Left and Rght . Defaults 0.
    @IBInspectable var paddingLeft: CGFloat = 0
    @IBInspectable var paddingRight: CGFloat = 0
    
    
   /* override open func textRect(forBounds bounds: CGRect) -> CGRect {
        return CGRect(x: bounds.origin.x + paddingLeft, y: bounds.origin.y, width: bounds.size.width - paddingLeft - paddingRight, height: bounds.size.height)
    }
    
    override open func editingRect(forBounds bounds: CGRect) -> CGRect {
        return textRect(forBounds: bounds)
    }*/
}


//MARK:- UIImageView Custom Properties
@IBDesignable open class WRCustomImageView: UIImageView {
    
    @IBInspectable var roundTopLeftCorner: Bool = false
    @IBInspectable var roundTopRightCorner: Bool = false
    @IBInspectable var roundBottomLeftCorner: Bool = false
    @IBInspectable var roundBottomRightCorner: Bool = false
    @IBInspectable var roundTopCorner: Bool = false
    
    func roundCorners(cornerRadius: Double) {
        var path = UIBezierPath()
        
        if roundTopLeftCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topLeft], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundTopRightCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundBottomLeftCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.bottomLeft], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundBottomRightCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.bottomRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundTopLeftCorner && roundTopRightCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topLeft, .topRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundTopLeftCorner && roundTopRightCorner && roundBottomLeftCorner && roundBottomRightCorner  {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topLeft, .topRight, .bottomLeft, .bottomRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
    
        let maskLayer = CAShapeLayer()
        maskLayer.frame = self.bounds
        maskLayer.path = path.cgPath
        self.layer.mask = maskLayer
    }
    
    open override func layoutSubviews() {
        if roundTopCorner{
            roundCorners(cornerRadius: 8)
        }
    }
    
    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
    @IBInspectable var cornerRadius: Double {
        get {
            return Double(self.layer.cornerRadius)
        }
        set {
            if !roundTopCorner{
                self.layer.cornerRadius = CGFloat(newValue)
            }else{
                roundCorners(cornerRadius: newValue)
            }
            
        }
    }
    
    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
    @IBInspectable var borderWidth: Double {
        get {
            return Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.
    @IBInspectable var borderColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.borderColor!)
        }
        set {
            self.layer.borderColor = newValue?.cgColor
        }
    }
    
    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
    @IBInspectable var shadowColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.shadowColor!)
        }
        set {
            self.layer.shadowColor = newValue?.cgColor
        }
    }
    
    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
    @IBInspectable var shadowOpacity: Float {
        get {
            return self.layer.shadowOpacity
        }
        set {
            self.layer.shadowOpacity = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowOffset: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    
    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
    @IBInspectable var shadowRadius: Double {
        get {
            return Double(self.layer.shadowRadius)
        }
        set {
            self.layer.shadowRadius = CGFloat(newValue)
        }
    }
    
    /*// Only override draw() if you perform custom drawing.
     // An empty implementation adversely affects performance during animation.
     override func draw `(_ rect: CGRect) {
     // Drawing code
     }*/
}

@IBDesignable  class WRCustomSlider: UISlider {
    /// custom slider track height
    @IBInspectable var trackHeight: CGFloat = 3
    
    override  func trackRect(forBounds bounds: CGRect) -> CGRect {
        // Use properly calculated rect
        var newRect = super.trackRect(forBounds: bounds)
        newRect.size.height = trackHeight
        return newRect
    }
}



@IBDesignable open class WRCustomButton: UIButton {
    
    @IBInspectable var roundTopLeftCorner: Bool = false
    @IBInspectable var roundTopRightCorner: Bool = false
    @IBInspectable var roundBottomLeftCorner: Bool = false
    @IBInspectable var roundBottomRightCorner: Bool = false
    @IBInspectable var roundTopCorner: Bool = false
    
    func roundCorners(cornerRadius: Double) {
        var path = UIBezierPath()
        
        if roundTopLeftCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topLeft], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundTopRightCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundBottomLeftCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.bottomLeft], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundBottomRightCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.bottomRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundTopLeftCorner && roundTopRightCorner {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topLeft, .topRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        if roundTopLeftCorner && roundTopRightCorner && roundBottomLeftCorner && roundBottomRightCorner  {
            path = UIBezierPath(roundedRect: self.bounds, byRoundingCorners: [.topLeft, .topRight, .bottomLeft, .bottomRight], cornerRadii: CGSize(width: cornerRadius, height: cornerRadius))
        }
        let maskLayer = CAShapeLayer()
        maskLayer.frame = self.bounds
        maskLayer.path = path.cgPath
        self.layer.mask = maskLayer
    }
    
    open override func layoutSubviews() {
        if roundTopCorner{
            roundCorners(cornerRadius: 8)
        }
    }
    
    /// When positive, the background of the layer will be drawn with rounded corners. Also effects the mask generated by the `masksToBounds' property. Defaults to zero. Animatable.
    @IBInspectable var cornerRadius: Double {
        get {
            return Double(self.layer.cornerRadius)
        }
        set {
            if !roundTopCorner{
                self.layer.cornerRadius = CGFloat(newValue)
            }else{
                roundCorners(cornerRadius: newValue)
            }
            
        }
    }
    
    /// The width of the layer's border, inset from the layer bounds. The border is composited above the layer's content and sublayers and includes the effects of the `cornerRadius' property. Defaults to zero. Animatable.
    @IBInspectable var borderWidth: Double {
        get {
            return Double(self.layer.borderWidth)
        }
        set {
            self.layer.borderWidth = CGFloat(newValue)
        }
    }
    
    /// The color of the layer's border. Defaults to opaque black. Colors created from tiled patterns are supported. Animatable.
    @IBInspectable var borderColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.borderColor!)
        }
        set {
            self.layer.borderColor = newValue?.cgColor
        }
    }
    
    /// The color of the shadow. Defaults to opaque black. Colors created from patterns are currently NOT supported. Animatable.
    @IBInspectable var shadowColor: UIColor? {
        get {
            return UIColor(cgColor: self.layer.shadowColor!)
        }
        set {
            self.layer.shadowColor = newValue?.cgColor
        }
    }
    
    /// The opacity of the shadow. Defaults to 0. Specifying a value outside the [0,1] range will give undefined results. Animatable.
    @IBInspectable var shadowOpacity: Float {
        get {
            return self.layer.shadowOpacity
        }
        set {
            self.layer.shadowOpacity = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowOffset: CGSize {
        get {
            return self.layer.shadowOffset
        }
        set {
            self.layer.shadowOffset = newValue
        }
    }
    
    /// The shadow offset. Defaults to (0, -3). Animatable.
    @IBInspectable var shadowSize: CGFloat {
        
        get {
            return self.layer.shadowPath as! CGFloat
        }
        set {
            let shadowPath = UIBezierPath(rect: CGRect(x: self.frame.origin.x - newValue / 2,
                                                       y: self.frame.origin.x - newValue / 2,
                                                       width: self.frame.size.width + newValue,
                                                       height: self.frame.size.height + newValue))
            self.layer.shadowPath = shadowPath.cgPath
        }
    }
    
    /// The blur radius used to create the shadow. Defaults to 3. Animatable.
    @IBInspectable var shadowRadius: Double {
        get {
            return Double(self.layer.shadowRadius)
        }
        set {
            self.layer.shadowRadius = CGFloat(newValue)
        }
    }
    
    /*// Only override draw() if you perform custom drawing.
    // An empty implementation adversely affects performance during animation.
    override func draw(_ rect: CGRect) {
        // Drawing code
    }*/
}
class TopRoundCornerView: UIView
{//Top Both

     override init(frame: CGRect) {
        super.init(frame: frame)
        BottomRoundCorners()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        BottomRoundCorners()
    }
    
    func BottomRoundCorners() {
        self.layer.maskedCorners = [.layerMaxXMinYCorner,.layerMinXMinYCorner]
    self.layer.masksToBounds = true
    self.layer.cornerRadius = 15
     }
  }
class BottomRoundCornerView: UIView
{//Bottom Both

     override init(frame: CGRect) {
        super.init(frame: frame)
        BottomRoundCorners()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        BottomRoundCorners()
    }
    
    func BottomRoundCorners() {
    self.layer.maskedCorners = [.layerMinXMaxYCorner,.layerMaxXMaxYCorner]
    self.layer.masksToBounds = true
    self.layer.cornerRadius = 15
     }
}
class LeadingRoundCornerView: UIView
{//Left
     override init(frame: CGRect) {
        super.init(frame: frame)
        BottomRoundCorners()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        BottomRoundCorners()
    }
    
    func BottomRoundCorners() {
        self.layer.maskedCorners = [.layerMinXMaxYCorner,.layerMinXMinYCorner]
    self.layer.masksToBounds = true
    self.layer.cornerRadius = 20
     }
}

class LeadingRoundCornerView10: UIView
{//Left
     override init(frame: CGRect) {
        super.init(frame: frame)
        BottomRoundCorners()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        BottomRoundCorners()
    }
    
    func BottomRoundCorners() {
        self.layer.maskedCorners = [.layerMinXMaxYCorner,.layerMinXMinYCorner]
    self.layer.masksToBounds = true
    self.layer.cornerRadius = 10
     }
}


class TrailingRoundCornerView: UIView
{//Trailing
     override init(frame: CGRect) {
        super.init(frame: frame)
        BottomRoundCorners()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        BottomRoundCorners()
    }
    
    func BottomRoundCorners() {
        self.layer.maskedCorners = [.layerMaxXMinYCorner,.layerMaxXMaxYCorner]
    self.layer.masksToBounds = true
    self.layer.cornerRadius = 10
     }
}
class TopRoundCornerImage: UIImageView
{
     override init(frame: CGRect) {
        super.init(frame: frame)
        TopRoundCorners()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        TopRoundCorners()
    }
    
    func TopRoundCorners() {
    self.layer.maskedCorners = [.layerMaxXMinYCorner,.layerMinXMinYCorner]
    self.layer.masksToBounds = true
    self.layer.cornerRadius = 12
     }
}

class LeadingRoundCornerImage: UIImageView
{
     override init(frame: CGRect) {
        super.init(frame: frame)
        LeadingRoundCorners()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        LeadingRoundCorners()
    }
    
    func LeadingRoundCorners() {
        self.layer.maskedCorners = [.layerMinXMaxYCorner,.layerMinXMinYCorner, .layerMaxXMinYCorner, .layerMaxXMaxYCorner]
    self.layer.masksToBounds = true
    self.layer.cornerRadius = 10
     }
}

//MARK HideshowView
extension UIView{
    func animShow(){
        UIView.animate(withDuration: 0.5, delay: 0, options: [.curveEaseIn],
                       animations: {
                        self.center.y -= self.bounds.height
                        self.layoutIfNeeded()
                       }, completion: nil)
        self.isHidden = false
    }
    func animHide(){
        UIView.animate(withDuration: 0.0, delay: 0, options: [.curveLinear],
                       animations: {
                        self.center.y += self.bounds.height
                        self.layoutIfNeeded()
                        
                       },  completion: {(_ completed: Bool) -> Void in
                        self.isHidden = true
                       })
    }
    func animShow1(){
        UIView.animate(withDuration: 0, delay: 0, options: [.curveEaseIn],
                       animations: {
                        self.center.y -= self.bounds.height
                        self.layoutIfNeeded()
                       }, completion: nil)
        self.isHidden = false
    }

}
